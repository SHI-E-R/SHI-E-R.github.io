{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"利用canvas玩转图片","slug":"利用canvas玩转图片","date":"2020-01-13T02:06:47.000Z","updated":"2020-01-13T02:09:16.267Z","comments":true,"path":"2020/01/13/利用canvas玩转图片/","link":"","permalink":"http://yoursite.com/2020/01/13/%E5%88%A9%E7%94%A8canvas%E7%8E%A9%E8%BD%AC%E5%9B%BE%E7%89%87/","excerpt":"","text":"介绍canvas是H5中新加的一个标签 html 1&lt;canvas width='1200' height='800'&gt; &lt;/canvas&gt; 标签主要的属性如图,仅需width和height两个 就俩? 看着很简单不是? 当然不是 ╮(╯▽╰)╭ , 因为canvas是一个需要和js结合使用的标签 html 123456789&lt;body&gt; &lt;canvas width='1200' height='800' id='canvas'&gt; &lt;/canvas&gt;&lt;/body&gt;&lt;script&gt; const canvas = document.getElementById('canvas') const ctx = canvas.getContext('2d') // 2d ? 有3d咩 ? 有 =&gt; webgl :) ...&lt;/script&gt; canvas拿的是画板, ctx拿的是画笔, 画图主要的是通过画笔不是, 所以我们使用的也基本上是ctx身上的属性和方法, ctx身上有许多画图的方法: 画线的 lineTo(x, y) 画矩形的 rect(x, y, width, height) 画弧 / 圆的 arc(x, y, r, startAng, endAng, true/false) 画文本的 fillText(&#39;Hello World!&#39;) 画图片的 drawImage(imgData, x, y, width, height) … 以上只是简写, 有许多细节并未说明, 想细学的可以去 w3c 或 mdn 本文只介绍canvas对图片的相关操作,也就是围绕drawImage方法展开 Tips: 以下操作都在node服务器下操作, 文本域下会存在跨域问题, 无法实现一些操作 玩法一: 图片的组合在工作中难免会遇到需要前端画图的场景,根据用户的选择,动态的生成海报之类的,这时候就需要使用我们的canvas了,先看代码 html 1234567891011121314&lt;body&gt; &lt;canvas width='384' height='683' id='canvas'&gt;&lt;/canvas&gt; // ? =&gt; 和图片大小相关&lt;/body&gt;&lt;script&gt; const canvas = document.getElementById('canvas') const ctx = canvas.getContext('2d') 咱继续 (*^▽^*) const img1 = new Image() img1.src = './qiu.png' img1.onload = () =&gt; &#123; ctx.drawImage(img1, 0, 0, canvas.width, canvas.height) &#125;&lt;/script&gt; ctx.drawImage(imgdata, x, y, width, height)方法的参数有5个,分别是: x 绘制图像的左上点x轴坐标 y 绘制图像的左上点y轴坐标 width 绘制图像的宽度 height 绘制图像的高度 imgdata 这个在MDN的叫法为CanvasImageSource说人话是canvas图像源, 还听不懂?没关系我也不懂,总之常用的就是本文中的HTMLImageElement和HTMLVideoElement 1HTMLImageElement&#96;和&#96;HTMLVideoElement&#96;又是啥? 哈哈,其实就是&#96;img标签&#96;和&#96;video标签 javascript 12345678const img1 = new Image() 等于const img1 = document.createElement('img')也等于&lt;img id='img' src=''&gt;&lt;/img&gt;const img1 = document.getElementById('img')&lt;video&gt;标签也可以哦 此时的界面 空荡荡的篮球显得很孤独 (ノへ￣、) , 所以,我们得为他加个伴 javascript 123456789101112const canvas = document.getElementById('canvas')const ctx = canvas.getContext('2d')const img1 = new Image()const img2 = new Image()img1.src = './qiu.png'img1.onload = () =&gt; &#123; ctx.drawImage(img1, 0, 0, canvas.width, canvas.height) img2.src = './cai.png' img2.onload = () =&gt; &#123; ctx.drawImage(img2, 40, 180, 315, 453) &#125;&#125; 看图 完美! (≧∀≦)ゞ tips1: 注意要在img1加载完成后的回调函数中在给img2赋值src, 因为后绘制的会抹除先绘制的, 会出现f覆盖关系错误的问题 tips2: 这拙略的抠图, 辣眼睛 : ( 以上就是canvas对图像进行组合的方法, so easy是不是! 玩法二 下载图片组合好了, 该怎么保存(下载)呢? 首先我们得知道下载可分为两种: 本地下载 服务端下载 本地下载是指纯前端操作, 不经过后端接口直接保存, 而服务端下载则是通过接口返回的图片数据下载 本次只讲本地下载 , 服务端下载我会在下篇node文章中讲明 那本地下载咋下呢? 看下图你就知道了: 没错, 就是右键另存为 (&gt;▽&lt;) 啥? 你不听? 你不会右键?? 你要能看的见的下载??? 好吧, 谁让我是个好人呢 先来个按钮 html 12&lt;canvas id='ctx' width=\"384\" height=\"683\"&gt;&lt;/canvas&gt;&lt;p&gt;&lt;button onclick='download()'&gt;下载&lt;/button&gt;&lt;/p&gt; 如图 javascript 1234567base64_img = canvas.toDataURL()const download = () =&gt; &#123; const a = document.createElement('a') a.href = base64_img a.download = 'download.jpg' a.click()&#125; canvas.toDataURL()方法是将画布(canvas)的信息转为base64格式 download方法则是模拟一个a标签点击, 此方法确实可以下载, 但有个小弊端就是下载后的图片会偏大(存储的大小), 这是由于转为base64格式所造成的 以上就是canvas图像的下载, 有些瑕疵, 但目前我也没找到别的好方法, 以后我会了会补全这篇文章的! canvas像素操作 - 图片滤镜换张图 html 1234567891011&lt;canvas id='ctx' width=\"1200\" height=\"800\"&gt;&lt;/canvas&gt;&lt;p&gt;&lt;button onclick='blackWhite()'&gt;黑白滤镜&lt;/button&gt;&lt;/p&gt;&lt;script&gt; const canvas = document.getElementById('ctx') const ctx = canvas.getContext('2d') const img = new Image() img.src = './flowers.webp' img.onload = () =&gt; &#123; ctx.drawImage(img, 0, 0, canvas.width, canvas.height) &#125;&lt;/script&gt; 本来想多举几个例子, 但写到这里有点晕晕的, 这里就举一个黑白滤镜的例子把 继续 javascript 123456789101112const blackWhite = () =&gt; &#123; let myData = ctx.getImageData(0, 0, canvas.width, canvas.height) let arr = [] for(let i = 0; i &lt; myData.data.length; i++) &#123; if ((i+1)%4 == 0) &#123; let total = (myData.data[i - 1] + myData.data[i - 2] + myData.data[i - 3]) / 3 myData.data[i - 1] = myData.data[i - 2] = myData.data[i - 3] = total &#125; &#125; ctx.putImageData(myData, 0, 0)&#125;ctx.getImageData(0, 0, canvas.width, canvas.height) 是拿到该画布上的所有像素点, 返回的格式是一个巨大的数组: javascript 1[255, 255, 0, 255, ...] 四位为一个像素点, 分别对应R = 255, G = 255, B == 0, A == 255, 也就是说改点是一个透明度为1的纯黄色像素点,知道了这个后, 想弄成黑白滤镜就有了方向 我们还得知道一个小知识, 那就是, 当R,G,B值相同时会显示为灰色, 且数值越大越亮, 如255, 255, 255 为白色 所以我们可以将每项的元素点的R,G,B加起来除以三赋值给他们, 就实现了黑白滤镜, 如下 javascript 12let total = (myData.data[i - 1] + myData.data[i - 2] + myData.data[i - 3]) / 3myData.data[i - 1] = myData.data[i - 2] = myData.data[i - 3] = total ctx.putImageData(myData, 0, 0)是将处理后的像素点又绘制到画布上 结果 总结以上就是canvas对图片的一些操作能力, 另外水平有限, 写的不好请谅解 最后 写的真的有点晕, 最后有点潦草了 文章作者: Mrpzx 文章链接: http://blog.mrpzx.cn/2020/01/07/%E5%88%A9%E7%94%A8canvas%E7%8E%A9%E8%BD%AC%E5%9B%BE%E7%89%87/ 版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 Mrpzx！","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-09T01:49:35.932Z","updated":"2020-01-08T07:24:13.913Z","comments":true,"path":"2020/01/09/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}