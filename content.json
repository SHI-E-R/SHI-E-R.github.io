{"meta":{"title":"Hexo","subtitle":"","description":"","author":"shier","url":"https://shi-e-r.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-05-07T06:10:11.706Z","updated":"2020-05-07T06:10:11.706Z","comments":false,"path":"categories/index.html","permalink":"https://shi-e-r.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-07T06:06:48.493Z","updated":"2020-05-07T06:06:48.493Z","comments":false,"path":"about/index.html","permalink":"https://shi-e-r.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2020-05-07T03:49:49.625Z","updated":"2020-05-07T03:49:49.625Z","comments":true,"path":"links/index.html","permalink":"https://shi-e-r.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-07T03:48:09.431Z","updated":"2020-05-07T03:48:09.431Z","comments":false,"path":"repository/index.html","permalink":"https://shi-e-r.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-07T06:12:35.502Z","updated":"2020-05-07T06:12:35.502Z","comments":false,"path":"tags/index.html","permalink":"https://shi-e-r.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"随记：当前时间（小时）在一天或者跨天时间区间内的比较","slug":"随记：当前时间（小时）在一天或者跨天时间区间内的比较","date":"2020-04-28T06:50:37.187Z","updated":"2020-04-28T06:50:37.188Z","comments":true,"path":"2020/04/28/随记：当前时间（小时）在一天或者跨天时间区间内的比较/","link":"","permalink":"https://shi-e-r.github.io/2020/04/28/%E9%9A%8F%E8%AE%B0%EF%BC%9A%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%EF%BC%88%E5%B0%8F%E6%97%B6%EF%BC%89%E5%9C%A8%E4%B8%80%E5%A4%A9%E6%88%96%E8%80%85%E8%B7%A8%E5%A4%A9%E6%97%B6%E9%97%B4%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"","text":"当前时间（小时）在一天或者跨天时间区间内的比较主要思路是转换成date格式进行比较，废话不多说上代码 1234567891011121314151617181920212223242526// 以 8:00-17:00 为例const testTime = '8:00-17:00'const date = new Date()const hour = date.getHours()const minutes = date.getMinutes()// 一步到位const startTime = testTime.split('-')[0].split(\":\")const endTime = testTime.split('-')[1].split(\":\")// beginTime 1588032038914 (2020-04-28 08:00:38)// finishTime 1588064410296 (2020-04-28 17:00:10)const beginTime = date.setHours(startTime[0], startTime[1])const finishTime = date.setHours(endTime[0], endTime[1])// 获取现在时分时间戳const nowTime = date.setHours(hour, minutes)// 一天内if (beginTime &lt; finishTime) &#123; if (nowTime &lt; beginTime || nowTime &gt; finishTime) &#123; // 当前时间不在时间段范围内 &#125;&#125; else &#123; // 跨天 if (nowTime &lt; beginTime &amp;&amp; nowTime &gt; finishTime) &#123; // 当前时间不在时间段范围内 &#125;&#125;","categories":[],"tags":[]},{"title":"利用canvas玩转图片","slug":"利用canvas玩转图片","date":"2020-04-26T06:03:57.053Z","updated":"2020-04-26T06:03:57.073Z","comments":true,"path":"2020/04/26/利用canvas玩转图片/","link":"","permalink":"https://shi-e-r.github.io/2020/04/26/%E5%88%A9%E7%94%A8canvas%E7%8E%A9%E8%BD%AC%E5%9B%BE%E7%89%87/","excerpt":"","text":"介绍canvas是H5中新加的一个标签 html 1&lt;canvas width&#x3D;&#39;1200&#39; height&#x3D;&#39;800&#39;&gt; &lt;&#x2F;canvas&gt; 标签主要的属性如图,仅需width和height两个 就俩? 看着很简单不是? 当然不是 ╮(╯▽╰)╭ , 因为canvas是一个需要和js结合使用的标签 html 123456789&lt;body&gt; &lt;canvas width&#x3D;&#39;1200&#39; height&#x3D;&#39;800&#39; id&#x3D;&#39;canvas&#39;&gt; &lt;&#x2F;canvas&gt;&lt;&#x2F;body&gt;&lt;script&gt; const canvas &#x3D; document.getElementById(&#39;canvas&#39;) const ctx &#x3D; canvas.getContext(&#39;2d&#39;) &#x2F;&#x2F; 2d ? 有3d咩 ? 有 &#x3D;&gt; webgl :) ...&lt;&#x2F;script&gt; canvas拿的是画板, ctx拿的是画笔, 画图主要的是通过画笔不是, 所以我们使用的也基本上是ctx身上的属性和方法, ctx身上有许多画图的方法: 画线的 lineTo(x, y) 画矩形的 rect(x, y, width, height) 画弧 / 圆的 arc(x, y, r, startAng, endAng, true/false) 画文本的 fillText(&#39;Hello World!&#39;) 画图片的 drawImage(imgData, x, y, width, height) … 以上只是简写, 有许多细节并未说明, 想细学的可以去 w3c 或 mdn 本文只介绍canvas对图片的相关操作,也就是围绕drawImage方法展开 Tips: 以下操作都在node服务器下操作, 文本域下会存在跨域问题, 无法实现一些操作 玩法一: 图片的组合在工作中难免会遇到需要前端画图的场景,根据用户的选择,动态的生成海报之类的,这时候就需要使用我们的canvas了,先看代码 html 1234567891011121314&lt;body&gt; &lt;canvas width&#x3D;&#39;384&#39; height&#x3D;&#39;683&#39; id&#x3D;&#39;canvas&#39;&gt;&lt;&#x2F;canvas&gt; &#x2F;&#x2F; ? &#x3D;&gt; 和图片大小相关&lt;&#x2F;body&gt;&lt;script&gt; const canvas &#x3D; document.getElementById(&#39;canvas&#39;) const ctx &#x3D; canvas.getContext(&#39;2d&#39;) 咱继续 (*^▽^*) const img1 &#x3D; new Image() img1.src &#x3D; &#39;.&#x2F;qiu.png&#39; img1.onload &#x3D; () &#x3D;&gt; &#123; ctx.drawImage(img1, 0, 0, canvas.width, canvas.height) &#125;&lt;&#x2F;script&gt; ctx.drawImage(imgdata, x, y, width, height)方法的参数有5个,分别是: x 绘制图像的左上点x轴坐标 y 绘制图像的左上点y轴坐标 width 绘制图像的宽度 height 绘制图像的高度 imgdata 这个在MDN的叫法为CanvasImageSource说人话是canvas图像源, 还听不懂?没关系我也不懂,总之常用的就是本文中的HTMLImageElement和HTMLVideoElement 1HTMLImageElement&#96;和&#96;HTMLVideoElement&#96;又是啥? 哈哈,其实就是&#96;img标签&#96;和&#96;video标签 javascript 12345678const img1 &#x3D; new Image() 等于const img1 &#x3D; document.createElement(&#39;img&#39;)也等于&lt;img id&#x3D;&#39;img&#39; src&#x3D;&#39;&#39;&gt;&lt;&#x2F;img&gt;const img1 &#x3D; document.getElementById(&#39;img&#39;)&lt;video&gt;标签也可以哦 此时的界面 空荡荡的篮球显得很孤独 (ノへ￣、) , 所以,我们得为他加个伴 javascript 123456789101112const canvas &#x3D; document.getElementById(&#39;canvas&#39;)const ctx &#x3D; canvas.getContext(&#39;2d&#39;)const img1 &#x3D; new Image()const img2 &#x3D; new Image()img1.src &#x3D; &#39;.&#x2F;qiu.png&#39;img1.onload &#x3D; () &#x3D;&gt; &#123; ctx.drawImage(img1, 0, 0, canvas.width, canvas.height) img2.src &#x3D; &#39;.&#x2F;cai.png&#39; img2.onload &#x3D; () &#x3D;&gt; &#123; ctx.drawImage(img2, 40, 180, 315, 453) &#125;&#125; 看图 完美! (≧∀≦)ゞ tips1: 注意要在img1加载完成后的回调函数中在给img2赋值src, 因为后绘制的会抹除先绘制的, 会出现f覆盖关系错误的问题 tips2: 这拙略的抠图, 辣眼睛 : ( 以上就是canvas对图像进行组合的方法, so easy是不是! 玩法二 下载图片组合好了, 该怎么保存(下载)呢? 首先我们得知道下载可分为两种: 本地下载 服务端下载 本地下载是指纯前端操作, 不经过后端接口直接保存, 而服务端下载则是通过接口返回的图片数据下载 本次只讲本地下载 , 服务端下载我会在下篇node文章中讲明 那本地下载咋下呢? 看下图你就知道了: 没错, 就是右键另存为 (&gt;▽&lt;) 啥? 你不听? 你不会右键?? 你要能看的见的下载??? 好吧, 谁让我是个好人呢 先来个按钮 html 12&lt;canvas id&#x3D;&#39;ctx&#39; width&#x3D;&quot;384&quot; height&#x3D;&quot;683&quot;&gt;&lt;&#x2F;canvas&gt;&lt;p&gt;&lt;button onclick&#x3D;&#39;download()&#39;&gt;下载&lt;&#x2F;button&gt;&lt;&#x2F;p&gt; 如图 javascript 1234567base64_img &#x3D; canvas.toDataURL()const download &#x3D; () &#x3D;&gt; &#123; const a &#x3D; document.createElement(&#39;a&#39;) a.href &#x3D; base64_img a.download &#x3D; &#39;download.jpg&#39; a.click()&#125; canvas.toDataURL()方法是将画布(canvas)的信息转为base64格式 download方法则是模拟一个a标签点击, 此方法确实可以下载, 但有个小弊端就是下载后的图片会偏大(存储的大小), 这是由于转为base64格式所造成的 以上就是canvas图像的下载, 有些瑕疵, 但目前我也没找到别的好方法, 以后我会了会补全这篇文章的! canvas像素操作 - 图片滤镜换张图 html 1234567891011&lt;canvas id&#x3D;&#39;ctx&#39; width&#x3D;&quot;1200&quot; height&#x3D;&quot;800&quot;&gt;&lt;&#x2F;canvas&gt;&lt;p&gt;&lt;button onclick&#x3D;&#39;blackWhite()&#39;&gt;黑白滤镜&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;&lt;script&gt; const canvas &#x3D; document.getElementById(&#39;ctx&#39;) const ctx &#x3D; canvas.getContext(&#39;2d&#39;) const img &#x3D; new Image() img.src &#x3D; &#39;.&#x2F;flowers.webp&#39; img.onload &#x3D; () &#x3D;&gt; &#123; ctx.drawImage(img, 0, 0, canvas.width, canvas.height) &#125;&lt;&#x2F;script&gt; 本来想多举几个例子, 但写到这里有点晕晕的, 这里就举一个黑白滤镜的例子把 继续 javascript 123456789101112const blackWhite &#x3D; () &#x3D;&gt; &#123; let myData &#x3D; ctx.getImageData(0, 0, canvas.width, canvas.height) let arr &#x3D; [] for(let i &#x3D; 0; i &lt; myData.data.length; i++) &#123; if ((i+1)%4 &#x3D;&#x3D; 0) &#123; let total &#x3D; (myData.data[i - 1] + myData.data[i - 2] + myData.data[i - 3]) &#x2F; 3 myData.data[i - 1] &#x3D; myData.data[i - 2] &#x3D; myData.data[i - 3] &#x3D; total &#125; &#125; ctx.putImageData(myData, 0, 0)&#125;ctx.getImageData(0, 0, canvas.width, canvas.height) 是拿到该画布上的所有像素点, 返回的格式是一个巨大的数组: javascript 1[255, 255, 0, 255, ...] 四位为一个像素点, 分别对应R = 255, G = 255, B == 0, A == 255, 也就是说改点是一个透明度为1的纯黄色像素点,知道了这个后, 想弄成黑白滤镜就有了方向 我们还得知道一个小知识, 那就是, 当R,G,B值相同时会显示为灰色, 且数值越大越亮, 如255, 255, 255 为白色 所以我们可以将每项的元素点的R,G,B加起来除以三赋值给他们, 就实现了黑白滤镜, 如下 javascript 12let total &#x3D; (myData.data[i - 1] + myData.data[i - 2] + myData.data[i - 3]) &#x2F; 3myData.data[i - 1] &#x3D; myData.data[i - 2] &#x3D; myData.data[i - 3] &#x3D; total ctx.putImageData(myData, 0, 0)是将处理后的像素点又绘制到画布上 结果 总结以上就是canvas对图片的一些操作能力, 另外水平有限, 写的不好请谅解 最后 写的真的有点晕, 最后有点潦草了 文章作者: Mrpzx 文章链接: http://blog.mrpzx.cn/2020/01/07/%E5%88%A9%E7%94%A8canvas%E7%8E%A9%E8%BD%AC%E5%9B%BE%E7%89%87/ 版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 Mrpzx！ 本文链接： http://yoursite.com/2020/01/13/%E5%88%A9%E7%94%A8canvas%E7%8E%A9%E8%BD%AC%E5%9B%BE%E7%89%87/ 版权声明： 本博客所有文章除特别声明外，均采用 CC BY 4.0 CN协议 许可协议。转载请注明出处！","categories":[],"tags":[]}],"categories":[],"tags":[]}